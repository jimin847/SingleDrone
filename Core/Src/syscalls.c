/**
 ******************************************************************************
 * @file      syscalls.c
 * @author    Auto-generated by STM32CubeIDE
 * @brief     STM32CubeIDE Minimal System calls file
 *
 * For more information about which c-functions
 * need which of these lowlevel functions
 * please consult the Newlib libc-manual
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2020-2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/* Includes */
#include <sys/stat.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>
#include "stm32f1xx_hal.h" // UART_HandleTypeDef 선언 포함

/* Variables */
// extern int __io_putchar(int ch) __attribute__((weak)); // 이 줄은 필요 없을 수 있습니다.
// extern int __io_getchar(void) __attribute__((weak));   // 이 줄은 필요 없을 수 있습니다.

// main.c에서 사용하는 UART 핸들을 extern으로 선언합니다.
// main.c에 `UART_HandleTypeDef huart2;` 가 선언되어 있어야 합니다.
extern UART_HandleTypeDef huart2;

char *__env[1] = { 0 };
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
  // Semihosting을 사용하지 않는다면 이 함수는 비워둡니다.
}

int _getpid(void)
{
  return 1;
}

int _kill(int pid, int sig)
{
  (void)pid;
  (void)sig;
  errno = EINVAL;
  return -1;
}

void _exit (int status)
{
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

// _read 함수는 필요에 따라 구현 (예: scanf 사용 시)
// 현재는 주석 처리
/*
__attribute__((weak)) int _read(int file, char *ptr, int len)
{
  (void)file;
  // UART로부터 데이터를 읽어오는 로직 구현
  // 예: HAL_UART_Receive(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
  // 실제 읽은 바이트 수를 반환해야 함
  return 0; // 임시
}
*/

// printf를 위해 _write 함수를 정의합니다.
// main.c에서 사용하는 huart2를 사용하도록 수정합니다.
int _write(int file, char *ptr, int len)
{
  (void)file; // file 인자는 사용하지 않음 (stdout, stderr 모두 UART로)
  if (HAL_UART_Transmit(&huart2, (uint8_t *)ptr, len, HAL_MAX_DELAY) == HAL_OK)
  {
    return len;
  }
  errno = EIO; // 전송 실패 시 I/O 에러 설정
  return -1;
}

// 중복되거나 사용되지 않는 __attribute__((weak)) int _write(...) 함수는 제거합니다.

int _close(int file)
{
  (void)file;
  return -1;
}

int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

int _isatty(int file)
{
  (void)file;
  return 1;
}

int _lseek(int file, int ptr, int dir)
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}

int _open(char *path, int flags, ...)
{
  (void)path;
  (void)flags;
  /* Pretend like we always fail */
  return -1;
}

int _wait(int *status)
{
  (void)status;
  errno = ECHILD;
  return -1;
}

int _unlink(char *name)
{
  (void)name;
  errno = ENOENT;
  return -1;
}

int _times(struct tms *buf)
{
  (void)buf;
  return -1;
}

int _stat(char *file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

int _link(char *old, char *new)
{
  (void)old;
  (void)new;
  errno = EMLINK;
  return -1;
}

int _fork(void)
{
  errno = EAGAIN;
  return -1;
}

int _execve(char *name, char **argv, char **env)
{
  (void)name;
  (void)argv;
  (void)env;
  errno = ENOMEM;
  return -1;
}
